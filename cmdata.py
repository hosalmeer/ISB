
'''
A class defined to store cohort metadata. This is the second layer in
getting at the actual data files. The first layer is getting the 
base information about the cohort that we have already saved in TCGA.

That base information needs to be retrieved by the 'get_cohort.py' 
script. The response sends back a json format file which has 
barcodes for each patient, and a barcode for each biological sample.

Note that some patients have multiple samples.

Second class fits into the first class as ONE item from the cohort.
'''


class cm(object):

    def __repr__(self):
        return "Cohort of %s samples" % self.size

    def __init__(self, resp, barcodes=None):
        '''
        Initialise by passing in the response of fetch(). Only works
        with sample barcodes (not patient).
        '''
        self.all    = list()
        self.size = len(resp)

        if barcodes:
            for s in range(len(resp)):

                tmp = sample_wbc(resp[s], barcodes[s])
                self.all.append(tmp)

        else:
            for s in range(len(resp)):

                tmp = sample(resp[s])
                self.all.append(tmp)

    def get_samples(self):
        return self.all

    def write_download_script(self):

        script_str['#! /bin/bash \n'] # Make list then '\n',join()

        for sample in self.get_samples():
            for dfile in sample.files:
                tmp = ' '.join(['gsutil cp', dfile.filepath, '.'])
                tmp = substitution_of_madness(tmp)

                script_str.append(tmp)

        print '\n'.join(script_str)

    def substitution_of_madness(self, string):
        '''
        Since I got an error saying the opentcga bucket does not 
        exist, I tried subbing in the slash, AND IT WORKED. 

        Do you know what this means? It means that ALL OF THE FILE 
        PATHS IN THE ISB-CGC PROJECT ARE WRONG.

        Obviously NO ONE is using this API except for us. This 
        substitution_of_madness is fixing the mistake of the idiot
        who autogenerated but didn't verify the cloud storage paths. 
        '''
        return re.sub( 'opentcga' , 'open/tcga' ,string)

class sample(object):
    '''
    Sample class, has no barcode. Each sample has seven attributes. 
    Bio-samples have multiple files. 
    '''
    def __repr__(self):

        return '< Biological sample without barcode for patient %s >'\
                % self.patient

    def __init__(self, sampledict):

        self.kind    = sampledict['kind']
        self.patient = sampledict['patient']
        self.fcount  = sampledict['data_details_count']
        self.etag    = sampledict['etag']
        self.aliquots= sampledict['aliquots']
        self.biospecimen_data = sampledict['biospecimen_data']

        self.__dd__  = sampledict['data_details']
        
        self.files   = list()
        for dd in self.__dd__:
            self.files.append(fdata(dd))  
        return

        
class sample_wbc(sample):

    def __repr__(self):

        return '< Biological sample %s for patient %s >'\
                % (self.barcode, self.patient)

    def __init__(self, sampledict, bcode):
        self.barcode = bcode
        super(sample_wbc,self).__init__(sampledict)
        

class fdata(object):
    '''
    Stores data for the individual file OF WHICH EACH BIOSAMPLE CAN
    HAVE MULTIPLE. Takes in a dict as input, one dict per file.
    '''

    def __init__(self, inp):
        '''
        There are variations in the fields here, so need to 
        '''

        # Mandatory fields, I don't think any datafile should be
        # missing these
        self.fields = inp.keys()
        self.SampleBarcode   = inp['SampleBarcode']
        self.Datatype        = inp['Datatype']
        self.filepath        = inp['cloud_storage_path']
        self.DataFileName    = inp['DataFileName']
        self.DataFileNameKey = inp['DataFileNameKey']
        self.SecurityProtocol= inp['SecurityProtocol']
        self.repository    = inp['Repository']

        # Putting in Nones might be a bad idea tbh
        # since it makes it look like something's there
        try:
            self.DataCenterName= inp['DataCenterName']
        except KeyError:
            self.DataCenterName= None
        try:
            self.Pipeline      = inp['Pipeline']
        except KeyError:
            self.Pipeline      = None
        try:
            self.DatafileUploaded = inp['DatafileUploaded']
        except KeyError:
            self.DatafileUploaded = None
        try:
            self.DataCenterType= inp['DataCenterType']
        except KeyError:
            self.DataCenterType= None
        try:
            self.project       = inp['Project']
        except KeyError:
            self.project       = None
        try:
            self.platform      = inp['Platform']
        except KeyError:
            self.platform      = None
        try:
            self.DataLevel     = inp['DataLevel']
        except KeyError:
            self.DataLevel     = None
        try:
            self.SDRFFileName  = inp['SDRFFileName']
        except KeyError:
            self.SDRFFileName  = None

